#!/usr/bin/env pwsh
param(
    [string]$TestDir = ".",
    [string]$TestExt = "rs",
    [string]$Binary = "cargo run --"
)

$ErrorActionPreference = "Stop"
$passed = 0
$failed = 0
$total = 0

function Run-Test {
    param([string]$Name, [string]$Command, [int]$ExpectedExit = 0)

    $script:total++
    Write-Host -NoNewline "  $Name ... "

    $ErrorActionPreference = "Continue"
    $result = Invoke-Expression "$Command 2>&1" | Out-String
    $exitCode = $LASTEXITCODE
    $ErrorActionPreference = "Stop"

    if ($exitCode -ne $ExpectedExit) {
        Write-Host "FAILED (exit=$exitCode, expected=$ExpectedExit)" -ForegroundColor Red
        $script:failed++
        return
    }

    Write-Host "OK" -ForegroundColor Green
    $script:passed++
}

Write-Host "`n=== E2E Tests (dir=$TestDir, ext=$TestExt) ===`n"

# Build first
Write-Host "Building..."
$ErrorActionPreference = "Continue"
& cargo build 2>&1 | Out-Null
$ErrorActionPreference = "Stop"
if ($LASTEXITCODE -ne 0) { Write-Host "Build failed!" -ForegroundColor Red; exit 1 }

# After successful build, use the compiled binary directly instead of "cargo run --"
# to avoid ~0.5-1s cargo freshness check overhead per test invocation.
if ($Binary -eq "cargo run --") {
    $Binary = ".\target\debug\search.exe"
    Write-Host "Using direct binary: $Binary"
}

# === SEQUENTIAL TESTS (share index state in %LOCALAPPDATA%/search-index/) ===

Write-Host "`n=== Sequential CLI tests ===`n"

# T01-T05: find
Run-Test "T01 find-filename"       "$Binary find main -d $TestDir -e $TestExt"
Run-Test "T02 find-contents"       "$Binary find `"fn main`" -d $TestDir -e $TestExt --contents"
Run-Test "T03 find-regex"          "$Binary find `"fn\s+\w+`" -d $TestDir -e $TestExt --contents --regex"
Run-Test "T04 find-case-insensitive" "$Binary find CONTENTINDEX -d $TestDir -e $TestExt --contents -i"
Run-Test "T05 find-count"          "$Binary find fn -d $TestDir -e $TestExt --contents -c"

# T06-T09: index + fast
Run-Test "T06 index-build"         "$Binary index -d $TestDir"
Run-Test "T07 fast-search"         "$Binary fast main -d $TestDir -e $TestExt"
Run-Test "T08 fast-regex-icase"    "$Binary fast `".*handler.*`" -d $TestDir -e $TestExt --regex -i"
Run-Test "T09 fast-dirs-only"      "$Binary fast src -d $TestDir --dirs-only"
Run-Test "T09a fast-multi-term"    "$Binary fast `"main,lib,handler`" -d $TestDir -e $TestExt"

# T10: content-index
Run-Test "T10 content-index"       "$Binary content-index -d $TestDir -e $TestExt"

# T11-T18: grep
Run-Test "T11 grep-single"         "$Binary grep tokenize -d $TestDir -e $TestExt"
Run-Test "T12 grep-multi-or"       "$Binary grep `"tokenize,posting`" -d $TestDir -e $TestExt"
Run-Test "T13 grep-multi-and"      "$Binary grep `"tokenize,posting`" -d $TestDir -e $TestExt --all"
Run-Test "T14 grep-regex"          "$Binary grep `".*stale.*`" -d $TestDir -e $TestExt --regex"
Run-Test "T15 grep-phrase"         "$Binary grep `"pub fn`" -d $TestDir -e $TestExt --phrase"
Run-Test "T15b grep-phrase-punct"  "$Binary grep `"pub(crate)`" -d $TestDir -e $TestExt --phrase"
Run-Test "T16 grep-context"        "$Binary grep is_stale -d $TestDir -e $TestExt --show-lines -C 2 --max-results 2"
Run-Test "T17 grep-exclude"        "$Binary grep ContentIndex -d $TestDir -e $TestExt --exclude-dir bench"
Run-Test "T18 grep-count"          "$Binary grep fn -d $TestDir -e $TestExt -c"
Run-Test "T24 grep-before-after"   "$Binary grep is_stale -d $TestDir -e $TestExt --show-lines -B 1 -A 3"

# T61-T64: grep substring (default) and --exact
Run-Test "T61 grep-substring-default" "$Binary grep contentindex -d $TestDir -e $TestExt"
Run-Test "T62 grep-substring-and"     "$Binary grep `"contentindex,tokenize`" -d $TestDir -e $TestExt --all"
Run-Test "T63 grep-exact"             "$Binary grep contentindex -d $TestDir -e $TestExt --exact"
Run-Test "T64 grep-regex-no-substr"   "$Binary grep `".*stale.*`" -d $TestDir -e $TestExt --regex"

# T19: info
Run-Test "T19 info"                "$Binary info"

# T20: def-index + def-audit
Run-Test "T20 def-index"           "$Binary def-index -d $TestDir -e $TestExt"
Run-Test "T-DEF-AUDIT def-audit"   "$Binary def-audit -d $TestDir -e $TestExt"

# T49: def-index with TypeScript
Run-Test "T49 def-index-ts"        "$Binary def-index -d $TestDir -e ts"
# T-EXT-CHECK: verify index files have new semantic extensions
# NOTE: must run AFTER def-index (T20) since .code-structure files are created by def-index
Write-Host -NoNewline "  T-EXT-CHECK index-file-extensions ... "
$total++
try {
    $idxDir = Join-Path $env:LOCALAPPDATA "search-index"
    $fileListFiles = Get-ChildItem -Path $idxDir -Filter "*.file-list" -ErrorAction SilentlyContinue
    $wordSearchFiles = Get-ChildItem -Path $idxDir -Filter "*.word-search" -ErrorAction SilentlyContinue
    $codeStructFiles = Get-ChildItem -Path $idxDir -Filter "*.code-structure" -ErrorAction SilentlyContinue
    $oldIdx = Get-ChildItem -Path $idxDir -Filter "*.idx" -ErrorAction SilentlyContinue
    $oldCidx = Get-ChildItem -Path $idxDir -Filter "*.cidx" -ErrorAction SilentlyContinue
    $oldDidx = Get-ChildItem -Path $idxDir -Filter "*.didx" -ErrorAction SilentlyContinue

    $extPassed = $true
    if (-not $fileListFiles) {
        Write-Host "FAILED (no .file-list files found)" -ForegroundColor Red
        $extPassed = $false
    }
    if (-not $wordSearchFiles) {
        Write-Host "FAILED (no .word-search files found)" -ForegroundColor Red
        $extPassed = $false
    }
    if (-not $codeStructFiles) {
        Write-Host "FAILED (no .code-structure files found)" -ForegroundColor Red
        $extPassed = $false
    }
    if ($oldIdx -or $oldCidx -or $oldDidx) {
        Write-Host "FAILED (old .idx/.cidx/.didx files found)" -ForegroundColor Red
        $extPassed = $false
    }
    if ($extPassed) {
        Write-Host "OK (.file-list=$($fileListFiles.Count), .word-search=$($wordSearchFiles.Count), .code-structure=$($codeStructFiles.Count))" -ForegroundColor Green
        $passed++
    }
    else {
        $failed++
    }
}
catch {
    Write-Host "FAILED (exception: $_)" -ForegroundColor Red
    $failed++
}


# T21-T23: error handling
Run-Test "T21 invalid-regex"       "$Binary grep `"[invalid`" -d $TestDir -e $TestExt --regex" -ExpectedExit 1
Run-Test "T22 nonexistent-dir"     "$Binary find test -d /nonexistent/path/xyz" -ExpectedExit 1

# T42/T42b: tips
Run-Test "T42 tips-strategy-recipes" "$Binary tips | Select-String 'STRATEGY RECIPES'"
Run-Test "T42b tips-query-budget"    "$Binary tips | Select-String 'Query budget'"

# Safety net: ensure content index exists before grep edge-case tests.
$ErrorActionPreference = "Continue"
Invoke-Expression "$Binary content-index -d $TestDir -e $TestExt 2>&1" | Out-Null
$ErrorActionPreference = "Stop"

# T54: grep with non-existent term should return 0 matches gracefully (not crash)
Run-Test "T54 grep-nonexistent-term" "$Binary grep ZZZNonExistentXYZ123 -d $TestDir -e $TestExt"

# T65: fast with invalid regex should return error (exit 1)
Run-Test "T65 fast-invalid-regex"    "$Binary fast `"[invalid`" -d $TestDir --regex" -ExpectedExit 1

# T76: fast with empty pattern
Run-Test "T76 fast-empty-pattern"    "$Binary fast `"`" -d $TestDir -e $TestExt" -ExpectedExit 2

# T80: grep with non-existent directory should return error (no index found)
Run-Test "T80 grep-nonexistent-dir"  "$Binary grep fn -d C:\nonexistent\fakepath123 -e $TestExt" -ExpectedExit 1

# T82: grep with --max-results 0 should work (0 means unlimited)
Run-Test "T82 grep-max-results-zero" "$Binary grep fn -d $TestDir -e $TestExt --max-results 0"

# T-SHUTDOWN: save-on-shutdown
Write-Host -NoNewline "  T-SHUTDOWN save-on-shutdown ... "
$total++
try {
    $t59dir = Join-Path $env:TEMP "search_e2e_shutdown_$PID"
    if (Test-Path $t59dir) { Remove-Item -Recurse -Force $t59dir }
    New-Item -ItemType Directory -Path $t59dir | Out-Null

    $t59file = Join-Path $t59dir "Original.cs"
    Set-Content -Path $t59file -Value "class Original { void Run() { } }"

    # Find the search binary (installed or debug)
    $searchBin = (Get-Command search.exe -ErrorAction SilentlyContinue).Source
    if (-not $searchBin) { $searchBin = ".\target\debug\search.exe" }

    $ErrorActionPreference = "Continue"
    & $searchBin content-index -d $t59dir -e cs 2>&1 | Out-Null
    $ErrorActionPreference = "Stop"

    $psi = New-Object System.Diagnostics.ProcessStartInfo
    $psi.FileName = $searchBin
    $psi.Arguments = "serve --dir `"$t59dir`" --ext cs --watch"
    $psi.UseShellExecute = $false
    $psi.RedirectStandardInput = $true
    $psi.RedirectStandardOutput = $true
    $psi.RedirectStandardError = $true
    $psi.CreateNoWindow = $true

    $t59proc = New-Object System.Diagnostics.Process
    $t59proc.StartInfo = $psi

    $stderrBuilder = New-Object System.Text.StringBuilder
    $stdoutBuilder = New-Object System.Text.StringBuilder
    $errHandler = { if ($EventArgs.Data) { $Event.MessageData.AppendLine($EventArgs.Data) } }
    $outHandler = { if ($EventArgs.Data) { $Event.MessageData.AppendLine($EventArgs.Data) } }

    $errEvent = Register-ObjectEvent -InputObject $t59proc -EventName ErrorDataReceived -Action $errHandler -MessageData $stderrBuilder
    $outEvent = Register-ObjectEvent -InputObject $t59proc -EventName OutputDataReceived -Action $outHandler -MessageData $stdoutBuilder

    $t59proc.Start() | Out-Null
    $t59proc.BeginErrorReadLine()
    $t59proc.BeginOutputReadLine()

    $initReq = '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{}}'
    $t59proc.StandardInput.WriteLine($initReq)

    # Wait for server startup + watcher init (typically <1.5s)
    Start-Sleep -Seconds 2

    Set-Content -Path $t59file -Value "class Modified { void Execute() { } }"

    # Wait for watcher debounce (500ms debounce + processing)
    Start-Sleep -Seconds 2

    $t59proc.StandardInput.Close()

    if (-not $t59proc.WaitForExit(15000)) {
        $t59proc.Kill()
        $t59proc.WaitForExit(5000) | Out-Null
    }

    Start-Sleep -Milliseconds 200

    Unregister-Event -SourceIdentifier $errEvent.Name -ErrorAction SilentlyContinue
    Unregister-Event -SourceIdentifier $outEvent.Name -ErrorAction SilentlyContinue

    $stderrContent = $stderrBuilder.ToString()

    if ($stderrContent -match "Content index saved on shutdown|saving indexes before shutdown") {
        Write-Host "OK" -ForegroundColor Green
        $passed++
    }
    else {
        $cidxFilesAfter = Get-ChildItem -Path (Join-Path $env:LOCALAPPDATA "search-index") -Filter "*.word-search" |
        Where-Object { $_.LastWriteTime -gt (Get-Date).AddMinutes(-1) }
        if ($cidxFilesAfter) {
            Write-Host "OK (verified via file timestamp)" -ForegroundColor Green
            $passed++
        }
        else {
            Write-Host "FAILED (no save-on-shutdown detected)" -ForegroundColor Red
            Write-Host "    stderr: $stderrContent" -ForegroundColor Yellow
            $failed++
        }
    }

    if (!$t59proc.HasExited) { $t59proc.Kill() }
    $t59proc.Dispose()
    Remove-Item -Recurse -Force $t59dir -ErrorAction SilentlyContinue
}
catch {
    Write-Host "FAILED (exception: $_)" -ForegroundColor Red
    $failed++
    if ($t59proc -and !$t59proc.HasExited) { $t59proc.Kill() }
    if ($t59proc) { $t59proc.Dispose() }
    if ($errEvent) { Unregister-Event -SourceIdentifier $errEvent.Name -ErrorAction SilentlyContinue }
    if ($outEvent) { Unregister-Event -SourceIdentifier $outEvent.Name -ErrorAction SilentlyContinue }
    Remove-Item -Recurse -Force $t59dir -ErrorAction SilentlyContinue
}

# === PARALLEL TEST SECTION ===
# These tests are independent: MCP callers tests use isolated temp directories,
# Git MCP tests are read-only. Safe to run concurrently via Start-Job.

Write-Host "`n=== Parallel MCP tests (Start-Job) ===`n"

$parallelTimer = [System.Diagnostics.Stopwatch]::StartNew()

# Resolve search binary to absolute path (jobs run in different working directory)
$searchBinAbs = (Get-Command search.exe -ErrorAction SilentlyContinue).Source
if (-not $searchBinAbs) {
    $searchBinAbs = (Resolve-Path ".\target\debug\search.exe" -ErrorAction SilentlyContinue).Path
}
if (-not $searchBinAbs) {
    Write-Host "ERROR: search.exe not found (not installed, no debug build)" -ForegroundColor Red
    exit 1
}
$projectDirAbs = (Resolve-Path $TestDir).Path

# --- Define parallel test scriptblocks ---
$testBlocks = @()

# T65-66: callers-local-var-types-down
$testBlocks += , {
    param($Bin, $Dir, $Ext)
    $name = "T65-66 callers-local-var-types-down"
    try {
        $tmpDir = Join-Path $env:TEMP "search_par_callers_down_$PID"
        if (Test-Path $tmpDir) { Remove-Item -Recurse -Force $tmpDir }
        New-Item -ItemType Directory -Path $tmpDir | Out-Null
        Set-Content -Path (Join-Path $tmpDir "validator.ts") -Value "export class OrderValidator {`n    check(): boolean {`n        return true;`n    }`n}"
        Set-Content -Path (Join-Path $tmpDir "service.ts") -Value "import { OrderValidator } from './validator';`n`nexport class OrderService {`n    processOrder(): void {`n        const validator = new OrderValidator();`n        validator.check();`n    }`n}"
        & $Bin content-index -d $tmpDir -e ts 2>&1 | Out-Null
        & $Bin def-index -d $tmpDir -e ts 2>&1 | Out-Null
        $msgs = @('{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}','{"jsonrpc":"2.0","method":"notifications/initialized"}','{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"search_callers","arguments":{"method":"processOrder","class":"OrderService","direction":"down","depth":1}}}') -join "`n"
        $output = ($msgs | & $Bin serve --dir $tmpDir --ext ts --definitions 2>$null) | Out-String
        $jsonLine = $output -split "`n" | Where-Object { $_ -match '"id"\s*:\s*5' } | Select-Object -Last 1
        & $Bin cleanup --dir $tmpDir 2>&1 | Out-Null
        Remove-Item -Recurse -Force $tmpDir -ErrorAction SilentlyContinue
        if ($jsonLine -and $jsonLine -match 'check') { return @{ Name = $name; Passed = $true; Output = "OK" } }
        else { return @{ Name = $name; Passed = $false; Output = "FAILED (check() not found in callTree)" } }
    } catch {
        if (Test-Path $tmpDir) { & $Bin cleanup --dir $tmpDir 2>&1 | Out-Null; Remove-Item -Recurse -Force $tmpDir -ErrorAction SilentlyContinue }
        return @{ Name = $name; Passed = $false; Output = "FAILED (exception: $_)" }
    }
}

# T67: callers-up-false-positive-filter
$testBlocks += , {
    param($Bin, $Dir, $Ext)
    $name = "T67 callers-up-false-positive-filter"
    try {
        $tmpDir = Join-Path $env:TEMP "search_par_callers_up_$PID"
        if (Test-Path $tmpDir) { Remove-Item -Recurse -Force $tmpDir }
        New-Item -ItemType Directory -Path $tmpDir | Out-Null
        Set-Content -Path (Join-Path $tmpDir "task.ts") -Value "export class TaskRunner {`n    resolve(): boolean {`n        return true;`n    }`n}"
        Set-Content -Path (Join-Path $tmpDir "orchestrator.ts") -Value "import { TaskRunner } from './task';`n`nexport class Orchestrator {`n    run(): void {`n        const task = new TaskRunner();`n        task.resolve();`n    }`n}"
        Set-Content -Path (Join-Path $tmpDir "pathhelper.ts") -Value "import * as path from 'path';`n`nexport class PathHelper {`n    getFullPath(): string {`n        return path.resolve('/tmp');`n    }`n}"
        & $Bin content-index -d $tmpDir -e ts 2>&1 | Out-Null
        & $Bin def-index -d $tmpDir -e ts 2>&1 | Out-Null
        $msgs = @('{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}','{"jsonrpc":"2.0","method":"notifications/initialized"}','{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"search_callers","arguments":{"method":"resolve","class":"TaskRunner","direction":"up","depth":1}}}') -join "`n"
        $output = ($msgs | & $Bin serve --dir $tmpDir --ext ts --definitions 2>$null) | Out-String
        $jsonLine = $output -split "`n" | Where-Object { $_ -match '"id"\s*:\s*5' } | Select-Object -Last 1
        & $Bin cleanup --dir $tmpDir 2>&1 | Out-Null
        Remove-Item -Recurse -Force $tmpDir -ErrorAction SilentlyContinue
        if (-not $jsonLine) { return @{ Name = $name; Passed = $false; Output = "FAILED (no JSON-RPC response)" } }
        if ($jsonLine -notmatch 'orchestrator') { return @{ Name = $name; Passed = $false; Output = "FAILED (orchestrator.ts not found)" } }
        if ($jsonLine -match 'pathhelper') { return @{ Name = $name; Passed = $false; Output = "FAILED (pathhelper.ts should be filtered)" } }
        return @{ Name = $name; Passed = $true; Output = "OK" }
    } catch {
        if (Test-Path $tmpDir) { & $Bin cleanup --dir $tmpDir 2>&1 | Out-Null; Remove-Item -Recurse -Force $tmpDir -ErrorAction SilentlyContinue }
        return @{ Name = $name; Passed = $false; Output = "FAILED (exception: $_)" }
    }
}

# T68: callers-up-graceful-fallback
$testBlocks += , {
    param($Bin, $Dir, $Ext)
    $name = "T68 callers-up-graceful-fallback"
    try {
        $tmpDir = Join-Path $env:TEMP "search_par_callers_fallback_$PID"
        if (Test-Path $tmpDir) { Remove-Item -Recurse -Force $tmpDir }
        New-Item -ItemType Directory -Path $tmpDir | Out-Null
        Set-Content -Path (Join-Path $tmpDir "dataservice.ts") -Value "export class DataService {`n    fetch(): any[] {`n        return [];`n    }`n}"
        Set-Content -Path (Join-Path $tmpDir "consumer.ts") -Value "import { DataService } from './dataservice';`n`nexport class Consumer {`n    load(): void {`n        const svc = new DataService();`n        const result = svc.fetch();`n    }`n}"
        & $Bin content-index -d $tmpDir -e ts 2>&1 | Out-Null
        & $Bin def-index -d $tmpDir -e ts 2>&1 | Out-Null
        $msgs = @('{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}','{"jsonrpc":"2.0","method":"notifications/initialized"}','{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"search_callers","arguments":{"method":"fetch","class":"DataService","direction":"up","depth":1}}}') -join "`n"
        $output = ($msgs | & $Bin serve --dir $tmpDir --ext ts --definitions 2>$null) | Out-String
        $jsonLine = $output -split "`n" | Where-Object { $_ -match '"id"\s*:\s*5' } | Select-Object -Last 1
        & $Bin cleanup --dir $tmpDir 2>&1 | Out-Null
        Remove-Item -Recurse -Force $tmpDir -ErrorAction SilentlyContinue
        if ($jsonLine -and $jsonLine -match 'consumer') { return @{ Name = $name; Passed = $true; Output = "OK" } }
        else { return @{ Name = $name; Passed = $false; Output = "FAILED (consumer.ts not found)" } }
    } catch {
        if (Test-Path $tmpDir) { & $Bin cleanup --dir $tmpDir 2>&1 | Out-Null; Remove-Item -Recurse -Force $tmpDir -ErrorAction SilentlyContinue }
        return @{ Name = $name; Passed = $false; Output = "FAILED (exception: $_)" }
    }
}

# T69: callers-up-comment-false-positive
$testBlocks += , {
    param($Bin, $Dir, $Ext)
    $name = "T69 callers-up-comment-false-positive"
    try {
        $tmpDir = Join-Path $env:TEMP "search_par_callers_comment_$PID"
        if (Test-Path $tmpDir) { Remove-Item -Recurse -Force $tmpDir }
        New-Item -ItemType Directory -Path $tmpDir | Out-Null
        Set-Content -Path (Join-Path $tmpDir "task-runner.ts") -Value "export class TaskRunner {`n    resolve(): void {`n        console.log(`"resolved`");`n    }`n}"
        Set-Content -Path (Join-Path $tmpDir "consumer.ts") -Value "import { TaskRunner } from `"./task-runner`";`n`nexport class Consumer {`n    processData(): void {`n        // We need to resolve the task before proceeding`n        // The resolve method handles cleanup`n        const runner = new TaskRunner();`n        runner.resolve();`n    }`n}"
        & $Bin content-index -d $tmpDir -e ts 2>&1 | Out-Null
        & $Bin def-index -d $tmpDir -e ts 2>&1 | Out-Null
        $msgs = @('{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}','{"jsonrpc":"2.0","method":"notifications/initialized"}','{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"search_callers","arguments":{"method":"resolve","class":"TaskRunner","direction":"up","depth":1}}}') -join "`n"
        $output = ($msgs | & $Bin serve --dir $tmpDir --ext ts --definitions 2>$null) | Out-String
        $jsonLine = $output -split "`n" | Where-Object { $_ -match '"id"\s*:\s*5' } | Select-Object -Last 1
        & $Bin cleanup --dir $tmpDir 2>&1 | Out-Null
        Remove-Item -Recurse -Force $tmpDir -ErrorAction SilentlyContinue
        if (-not $jsonLine) { return @{ Name = $name; Passed = $false; Output = "FAILED (no JSON-RPC response)" } }
        if ($jsonLine -notmatch 'processData') { return @{ Name = $name; Passed = $false; Output = "FAILED (processData not found)" } }
        if ($jsonLine -notmatch 'totalNodes[^0-9]+1[^0-9]') { return @{ Name = $name; Passed = $false; Output = "FAILED (expected totalNodes=1)" } }
        return @{ Name = $name; Passed = $true; Output = "OK" }
    } catch {
        if (Test-Path $tmpDir) { & $Bin cleanup --dir $tmpDir 2>&1 | Out-Null; Remove-Item -Recurse -Force $tmpDir -ErrorAction SilentlyContinue }
        return @{ Name = $name; Passed = $false; Output = "FAILED (exception: $_)" }
    }
}

# T-FIX3-EXPR-BODY: C# expression body property call sites
$testBlocks += , {
    param($Bin, $Dir, $Ext)
    $name = "T-FIX3-EXPR-BODY callers-csharp-expression-body"
    try {
        $tmpDir = Join-Path $env:TEMP "search_par_expr_body_$PID"
        if (Test-Path $tmpDir) { Remove-Item -Recurse -Force $tmpDir }
        New-Item -ItemType Directory -Path $tmpDir | Out-Null
        Set-Content -Path (Join-Path $tmpDir "NameProvider.cs") -Value "namespace TestApp`n{`n    public class NameProvider`n    {`n        public string GetName() => `"test`";`n    }`n}"
        Set-Content -Path (Join-Path $tmpDir "Consumer.cs") -Value "namespace TestApp`n{`n    public class Consumer`n    {`n        private NameProvider _provider;`n        public string DisplayName => _provider.GetName();`n    }`n}"
        & $Bin content-index -d $tmpDir -e cs 2>&1 | Out-Null
        & $Bin def-index -d $tmpDir -e cs 2>&1 | Out-Null
        $msgs = @('{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}','{"jsonrpc":"2.0","method":"notifications/initialized"}','{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"search_callers","arguments":{"method":"GetName","class":"NameProvider","direction":"up","depth":1}}}') -join "`n"
        $output = ($msgs | & $Bin serve --dir $tmpDir --ext cs --definitions 2>$null) | Out-String
        $jsonLine = $output -split "`n" | Where-Object { $_ -match '"id"\s*:\s*5' } | Select-Object -Last 1
        & $Bin cleanup --dir $tmpDir 2>&1 | Out-Null
        Remove-Item -Recurse -Force $tmpDir -ErrorAction SilentlyContinue
        if ($jsonLine -and $jsonLine -match 'DisplayName') { return @{ Name = $name; Passed = $true; Output = "OK" } }
        else { return @{ Name = $name; Passed = $false; Output = "FAILED (DisplayName not found)" } }
    } catch {
        if (Test-Path $tmpDir) { & $Bin cleanup --dir $tmpDir 2>&1 | Out-Null; Remove-Item -Recurse -Force $tmpDir -ErrorAction SilentlyContinue }
        return @{ Name = $name; Passed = $false; Output = "FAILED (exception: $_)" }
    }
}

# T-FIX3-VERIFY: No false positives from missing call-site data
$testBlocks += , {
    param($Bin, $Dir, $Ext)
    $name = "T-FIX3-VERIFY callers-no-false-positives-missing-data"
    try {
        $tmpDir = Join-Path $env:TEMP "search_par_verify_$PID"
        if (Test-Path $tmpDir) { Remove-Item -Recurse -Force $tmpDir }
        New-Item -ItemType Directory -Path $tmpDir | Out-Null
        Set-Content -Path (Join-Path $tmpDir "DataService.cs") -Value "namespace TestApp`n{`n    public class DataService`n    {`n        public void Process() { }`n    }`n}"
        Set-Content -Path (Join-Path $tmpDir "RealCaller.cs") -Value "namespace TestApp`n{`n    public class RealCaller`n    {`n        private DataService _service;`n        public void Execute()`n        {`n            _service.Process();`n        }`n    }`n}"
        Set-Content -Path (Join-Path $tmpDir "FalseCaller.cs") -Value "namespace TestApp`n{`n    public class FalseCaller`n    {`n        public void DoWork()`n        {`n            var msg = `"We need to Process the data`";`n            System.Console.WriteLine(msg);`n        }`n    }`n}"
        & $Bin content-index -d $tmpDir -e cs 2>&1 | Out-Null
        & $Bin def-index -d $tmpDir -e cs 2>&1 | Out-Null
        $msgs = @('{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}','{"jsonrpc":"2.0","method":"notifications/initialized"}','{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"search_callers","arguments":{"method":"Process","class":"DataService","direction":"up","depth":1}}}') -join "`n"
        $output = ($msgs | & $Bin serve --dir $tmpDir --ext cs --definitions 2>$null) | Out-String
        $jsonLine = $output -split "`n" | Where-Object { $_ -match '"id"\s*:\s*5' } | Select-Object -Last 1
        & $Bin cleanup --dir $tmpDir 2>&1 | Out-Null
        Remove-Item -Recurse -Force $tmpDir -ErrorAction SilentlyContinue
        if (-not $jsonLine) { return @{ Name = $name; Passed = $false; Output = "FAILED (no response)" } }
        if ($jsonLine -notmatch 'RealCaller') { return @{ Name = $name; Passed = $false; Output = "FAILED (RealCaller not found)" } }
        if ($jsonLine -match 'FalseCaller') { return @{ Name = $name; Passed = $false; Output = "FAILED (FalseCaller should be filtered)" } }
        return @{ Name = $name; Passed = $true; Output = "OK" }
    } catch {
        if (Test-Path $tmpDir) { & $Bin cleanup --dir $tmpDir 2>&1 | Out-Null; Remove-Item -Recurse -Force $tmpDir -ErrorAction SilentlyContinue }
        return @{ Name = $name; Passed = $false; Output = "FAILED (exception: $_)" }
    }
}

# T-FIX3-LAMBDA: Lambda calls in arguments captured (C#)
$testBlocks += , {
    param($Bin, $Dir, $Ext)
    $name = "T-FIX3-LAMBDA callers-csharp-lambda-in-args"
    try {
        $tmpDir = Join-Path $env:TEMP "search_par_lambda_$PID"
        if (Test-Path $tmpDir) { Remove-Item -Recurse -Force $tmpDir }
        New-Item -ItemType Directory -Path $tmpDir | Out-Null
        Set-Content -Path (Join-Path $tmpDir "Validator.cs") -Value "using System;`nnamespace TestApp`n{`n    public class Validator`n    {`n        public bool Validate(string s)`n        {`n            return s.Length > 0;`n        }`n    }`n}"
        Set-Content -Path (Join-Path $tmpDir "Processor.cs") -Value "using System;`nusing System.Collections.Generic;`nnamespace TestApp`n{`n    public class Processor`n    {`n        private Validator _validator;`n        public void ProcessAll(List<string> items)`n        {`n            items.ForEach(x => _validator.Validate(x));`n        }`n    }`n}"
        & $Bin content-index -d $tmpDir -e cs 2>&1 | Out-Null
        & $Bin def-index -d $tmpDir -e cs 2>&1 | Out-Null
        $msgs = @('{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}','{"jsonrpc":"2.0","method":"notifications/initialized"}','{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"search_callers","arguments":{"method":"Validate","class":"Validator","direction":"up","depth":1}}}') -join "`n"
        $output = ($msgs | & $Bin serve --dir $tmpDir --ext cs --definitions 2>$null) | Out-String
        $jsonLine = $output -split "`n" | Where-Object { $_ -match '"id"\s*:\s*5' } | Select-Object -Last 1
        & $Bin cleanup --dir $tmpDir 2>&1 | Out-Null
        Remove-Item -Recurse -Force $tmpDir -ErrorAction SilentlyContinue
        if ($jsonLine -and $jsonLine -match 'ProcessAll') { return @{ Name = $name; Passed = $true; Output = "OK" } }
        else { return @{ Name = $name; Passed = $false; Output = "FAILED (ProcessAll not found)" } }
    } catch {
        if (Test-Path $tmpDir) { & $Bin cleanup --dir $tmpDir 2>&1 | Out-Null; Remove-Item -Recurse -Force $tmpDir -ErrorAction SilentlyContinue }
        return @{ Name = $name; Passed = $false; Output = "FAILED (exception: $_)" }
    }
}

# T-OVERLOAD-DEDUP-UP: Overloaded callers not collapsed (direction=up)
$testBlocks += , {
    param($Bin, $Dir, $Ext)
    $name = "T-OVERLOAD-DEDUP-UP callers-overloads-not-collapsed-up"
    try {
        $tmpDir = Join-Path $env:TEMP "search_par_overload_up_$PID"
        if (Test-Path $tmpDir) { Remove-Item -Recurse -Force $tmpDir }
        New-Item -ItemType Directory -Path $tmpDir | Out-Null
        Set-Content -Path (Join-Path $tmpDir "Validator.cs") -Value "namespace TestApp`n{`n    public class Validator`n    {`n        public bool Validate() { return true; }`n    }`n}"
        Set-Content -Path (Join-Path $tmpDir "Processor.cs") -Value "namespace TestApp`n{`n    public class Processor`n    {`n        private Validator _validator;`n        public void Process(int x)`n        {`n            _validator.Validate();`n        }`n        public void Process(string s)`n        {`n            _validator.Validate();`n        }`n    }`n}"
        & $Bin content-index -d $tmpDir -e cs 2>&1 | Out-Null
        & $Bin def-index -d $tmpDir -e cs 2>&1 | Out-Null
        $msgs = @('{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}','{"jsonrpc":"2.0","method":"notifications/initialized"}','{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"search_callers","arguments":{"method":"Validate","class":"Validator","direction":"up","depth":1}}}') -join "`n"
        $output = ($msgs | & $Bin serve --dir $tmpDir --ext cs --definitions 2>$null) | Out-String
        $jsonLine = $output -split "`n" | Where-Object { $_ -match '"id"\s*:\s*5' } | Select-Object -Last 1
        & $Bin cleanup --dir $tmpDir 2>&1 | Out-Null
        Remove-Item -Recurse -Force $tmpDir -ErrorAction SilentlyContinue
        if ($jsonLine) {
            $processMatches = [regex]::Matches($jsonLine, '\\?"Process\\?"')
            if ($processMatches.Count -ge 2) { return @{ Name = $name; Passed = $true; Output = "OK" } }
            else { return @{ Name = $name; Passed = $false; Output = "FAILED (expected 2 Process overloads, got $($processMatches.Count))" } }
        } else { return @{ Name = $name; Passed = $false; Output = "FAILED (no response)" } }
    } catch {
        if (Test-Path $tmpDir) { & $Bin cleanup --dir $tmpDir 2>&1 | Out-Null; Remove-Item -Recurse -Force $tmpDir -ErrorAction SilentlyContinue }
        return @{ Name = $name; Passed = $false; Output = "FAILED (exception: $_)" }
    }
}

# T-SAME-NAME-IFACE: Same method name on unrelated interfaces
$testBlocks += , {
    param($Bin, $Dir, $Ext)
    $name = "T-SAME-NAME-IFACE callers-same-name-unrelated-iface"
    try {
        $tmpDir = Join-Path $env:TEMP "search_par_same_name_iface_$PID"
        if (Test-Path $tmpDir) { Remove-Item -Recurse -Force $tmpDir }
        New-Item -ItemType Directory -Path $tmpDir | Out-Null
        Set-Content -Path (Join-Path $tmpDir "IServiceA.cs") -Value "namespace TestApp`n{`n    public interface IServiceA`n    {`n        void Execute();`n    }`n}"
        Set-Content -Path (Join-Path $tmpDir "IServiceB.cs") -Value "namespace TestApp`n{`n    public interface IServiceB`n    {`n        void Execute();`n    }`n}"
        Set-Content -Path (Join-Path $tmpDir "ServiceA.cs") -Value "namespace TestApp`n{`n    public class ServiceA : IServiceA`n    {`n        public void Execute() { }`n    }`n}"
        Set-Content -Path (Join-Path $tmpDir "ServiceB.cs") -Value "namespace TestApp`n{`n    public class ServiceB : IServiceB`n    {`n        public void Execute() { }`n    }`n}"
        Set-Content -Path (Join-Path $tmpDir "Consumer.cs") -Value "namespace TestApp`n{`n    public class Consumer`n    {`n        private IServiceB _serviceB;`n        public void DoWork()`n        {`n            _serviceB.Execute();`n        }`n    }`n}"
        & $Bin content-index -d $tmpDir -e cs 2>&1 | Out-Null
        & $Bin def-index -d $tmpDir -e cs 2>&1 | Out-Null
        $msgs = @('{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}','{"jsonrpc":"2.0","method":"notifications/initialized"}','{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"search_callers","arguments":{"method":"Execute","class":"ServiceA","direction":"up","depth":1}}}') -join "`n"
        $output = ($msgs | & $Bin serve --dir $tmpDir --ext cs --definitions 2>$null) | Out-String
        $jsonLine = $output -split "`n" | Where-Object { $_ -match '"id"\s*:\s*5' } | Select-Object -Last 1
        & $Bin cleanup --dir $tmpDir 2>&1 | Out-Null
        Remove-Item -Recurse -Force $tmpDir -ErrorAction SilentlyContinue
        if (-not $jsonLine) { return @{ Name = $name; Passed = $false; Output = "FAILED (no response)" } }
        if ($jsonLine -match 'Consumer') { return @{ Name = $name; Passed = $false; Output = "FAILED (Consumer should NOT appear)" } }
        if ($jsonLine -notmatch 'totalNodes[^0-9]+0[^0-9]') { return @{ Name = $name; Passed = $false; Output = "FAILED (expected totalNodes=0)" } }
        return @{ Name = $name; Passed = $true; Output = "OK" }
    } catch {
        if (Test-Path $tmpDir) { & $Bin cleanup --dir $tmpDir 2>&1 | Out-Null; Remove-Item -Recurse -Force $tmpDir -ErrorAction SilentlyContinue }
        return @{ Name = $name; Passed = $false; Output = "FAILED (exception: $_)" }
    }
}

# T-SERVE-HELP-TOOLS: verify serve --help lists key tools
$testBlocks += , {
    param($Bin, $Dir, $Ext)
    $name = "T-SERVE-HELP-TOOLS serve-help-tool-list"
    try {
        $helpOutput = & $Bin serve --help 2>&1 | Out-String
        $requiredTools = @("search_branch_status", "search_git_blame", "search_help", "search_reindex_definitions")
        foreach ($tool in $requiredTools) {
            if ($helpOutput -notmatch $tool) { return @{ Name = $name; Passed = $false; Output = "FAILED (missing: $tool)" } }
        }
        return @{ Name = $name; Passed = $true; Output = "OK" }
    } catch { return @{ Name = $name; Passed = $false; Output = "FAILED (exception: $_)" } }
}

# T-BRANCH-STATUS: smoke test for search_branch_status MCP tool
$testBlocks += , {
    param($Bin, $Dir, $Ext)
    $name = "T-BRANCH-STATUS branch-status-smoke"
    try {
        $repoPath = $Dir -replace '\\', '/'
        $msgs = @('{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}','{"jsonrpc":"2.0","method":"notifications/initialized"}',('{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"search_branch_status","arguments":{"repo":"' + $repoPath + '"}}}')) -join "`n"
        $output = ($msgs | & $Bin serve --dir $Dir --ext $Ext 2>$null) | Out-String
        $jsonLine = $output -split "`n" | Where-Object { $_ -match '"id"\s*:\s*5' } | Select-Object -Last 1
        if ($jsonLine -and $jsonLine -match 'currentBranch' -and $jsonLine -match 'isMainBranch' -and $jsonLine -notmatch '"isError"\s*:\s*true') { return @{ Name = $name; Passed = $true; Output = "OK" } }
        else { return @{ Name = $name; Passed = $false; Output = "FAILED (missing fields or isError)" } }
    } catch { return @{ Name = $name; Passed = $false; Output = "FAILED (exception: $_)" } }
}

# T-GIT-FILE-NOT-FOUND: nonexistent file returns warning, not error
$testBlocks += , {
    param($Bin, $Dir, $Ext)
    $name = "T-GIT-FILE-NOT-FOUND git-history-file-warning"
    try {
        $repoPath = $Dir -replace '\\', '/'
        $msgs = @('{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}','{"jsonrpc":"2.0","method":"notifications/initialized"}',('{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"search_git_history","arguments":{"repo":"' + $repoPath + '","file":"DOES_NOT_EXIST_12345.txt"}}}')) -join "`n"
        $output = ($msgs | & $Bin serve --dir $Dir --ext $Ext 2>$null) | Out-String
        $jsonLine = $output -split "`n" | Where-Object { $_ -match '"id"\s*:\s*5' } | Select-Object -Last 1
        if ($jsonLine -and $jsonLine -match 'warning' -and $jsonLine -notmatch '"isError"\s*:\s*true') { return @{ Name = $name; Passed = $true; Output = "OK" } }
        else { return @{ Name = $name; Passed = $false; Output = "FAILED (expected warning, no isError)" } }
    } catch { return @{ Name = $name; Passed = $false; Output = "FAILED (exception: $_)" } }
}

# T-GIT-NOCACHE: noCache parameter returns valid result
$testBlocks += , {
    param($Bin, $Dir, $Ext)
    $name = "T-GIT-NOCACHE git-history-nocache"
    try {
        $repoPath = $Dir -replace '\\', '/'
        $msgs = @('{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}','{"jsonrpc":"2.0","method":"notifications/initialized"}',('{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"search_git_history","arguments":{"repo":"' + $repoPath + '","file":"Cargo.toml","noCache":true,"maxResults":1}}}')) -join "`n"
        $output = ($msgs | & $Bin serve --dir $Dir --ext $Ext 2>$null) | Out-String
        $jsonLine = $output -split "`n" | Where-Object { $_ -match '"id"\s*:\s*5' } | Select-Object -Last 1
        if ($jsonLine -and $jsonLine -match 'commits' -and $jsonLine -notmatch '"isError"\s*:\s*true') { return @{ Name = $name; Passed = $true; Output = "OK" } }
        else { return @{ Name = $name; Passed = $false; Output = "FAILED (expected commits, no isError)" } }
    } catch { return @{ Name = $name; Passed = $false; Output = "FAILED (exception: $_)" } }
}

# T-GIT-TOTALCOMMITS: totalCommits shows real total, not truncated count
$testBlocks += , {
    param($Bin, $Dir, $Ext)
    $name = "T-GIT-TOTALCOMMITS git-history-total-vs-returned"
    try {
        $repoPath = $Dir -replace '\\', '/'
        $msgs = @('{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}','{"jsonrpc":"2.0","method":"notifications/initialized"}',('{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"search_git_history","arguments":{"repo":"' + $repoPath + '","file":"Cargo.toml","maxResults":1}}}')) -join "`n"
        $output = ($msgs | & $Bin serve --dir $Dir --ext $Ext 2>$null) | Out-String
        $jsonLine = $output -split "`n" | Where-Object { $_ -match '"id"\s*:\s*5' } | Select-Object -Last 1
        if (-not $jsonLine) { return @{ Name = $name; Passed = $false; Output = "FAILED (no response)" } }
        $totalMatch = [regex]::Match($jsonLine, 'totalCommits\\?"?\s*:\s*(\d+)')
        $returnedMatch = [regex]::Match($jsonLine, 'returned\\?"?\s*:\s*(\d+)')
        if ($totalMatch.Success -and $returnedMatch.Success) {
            $totalVal = [int]$totalMatch.Groups[1].Value
            $returnedVal = [int]$returnedMatch.Groups[1].Value
            if ($totalVal -gt $returnedVal -and $returnedVal -eq 1) { return @{ Name = $name; Passed = $true; Output = "OK (total=$totalVal, returned=$returnedVal)" } }
            else { return @{ Name = $name; Passed = $false; Output = "FAILED (total=$totalVal should be > returned=$returnedVal)" } }
        } else { return @{ Name = $name; Passed = $false; Output = "FAILED (could not parse counts)" } }
    } catch { return @{ Name = $name; Passed = $false; Output = "FAILED (exception: $_)" } }
}

# T-GIT-CACHE: Git cache routing
$testBlocks += , {
    param($Bin, $Dir, $Ext)
    $name = "T-GIT-CACHE git-cache-routing"
    try {
        $repoPath = $Dir -replace '\\', '/'
        $msgs = @('{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}','{"jsonrpc":"2.0","method":"notifications/initialized"}',('{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"search_git_history","arguments":{"repo":"' + $repoPath + '","file":"Cargo.toml","maxResults":2}}}')) -join "`n"
        $output = ($msgs | & $Bin serve --dir $Dir --ext $Ext 2>$null) | Out-String
        $jsonLine = $output -split "`n" | Where-Object { $_ -match '"id"\s*:\s*5' } | Select-Object -Last 1
        if ($jsonLine -and $jsonLine -match 'commits') { return @{ Name = $name; Passed = $true; Output = "OK" } }
        else { return @{ Name = $name; Passed = $false; Output = "FAILED (no commits)" } }
    } catch { return @{ Name = $name; Passed = $false; Output = "FAILED (exception: $_)" } }
}

# --- Launch all parallel jobs ---
$parallelJobs = @()
foreach ($block in $testBlocks) {
    $parallelJobs += Start-Job -ScriptBlock $block -ArgumentList $searchBinAbs, $projectDirAbs, $TestExt
}
Write-Host "  Launched $($parallelJobs.Count) parallel test jobs, waiting..."

# Wait with timeout (120s should be more than enough)
$null = $parallelJobs | Wait-Job -Timeout 120

# --- Collect and display results ---
foreach ($job in $parallelJobs) {
    $total++
    if ($job.State -eq 'Running') {
        Stop-Job -Job $job
        Write-Host "  (timed out job) ... FAILED (timeout after 120s)" -ForegroundColor Red
        $failed++
    }
    elseif ($job.State -eq 'Failed') {
        $errMsg = $job.ChildJobs[0].JobStateInfo.Reason.Message
        Write-Host "  (crashed job) ... FAILED (job error: $errMsg)" -ForegroundColor Red
        $failed++
    }
    else {
        $result = Receive-Job -Job $job -ErrorAction SilentlyContinue
        if ($result -and $result.Name) {
            Write-Host -NoNewline "  $($result.Name) ... "
            if ($result.Passed) {
                Write-Host "$($result.Output)" -ForegroundColor Green
                $passed++
            }
            else {
                Write-Host "$($result.Output)" -ForegroundColor Red
                $failed++
            }
        }
        else {
            Write-Host "  (unknown job) ... FAILED (no result returned)" -ForegroundColor Red
            $failed++
        }
    }
    Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
}

$parallelTimer.Stop()
Write-Host "`n  Parallel batch: $($parallelJobs.Count) tests in $([math]::Round($parallelTimer.Elapsed.TotalSeconds, 1))s"

# T25-T52: serve (MCP)
Write-Host "  T25-T52: MCP serve tests - run manually (see e2e-test-plan.md)"

# T53-T58: TypeScript callers (MCP)
Write-Host "  T53-T58: TypeScript callers MCP tests - run manually (see e2e-test-plan.md)"

# Cleanup: remove index files created during E2E tests
Write-Host "`nCleaning up test indexes..."
$ErrorActionPreference = "Continue"
Invoke-Expression "$Binary cleanup --dir $TestDir 2>&1" | Out-Null
Invoke-Expression "$Binary cleanup 2>&1" | Out-Null
$ErrorActionPreference = "Stop"

Write-Host "`n=== Results: $passed passed, $failed failed, $total total ===`n"
if ($failed -gt 0) { exit 1 }